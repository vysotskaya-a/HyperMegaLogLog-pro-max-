# Отчёт по исследованию HyperLogLog

## 1. Постановка задачи
Необходимо реализовать HyperLogLog для оценки числа уникальных объектов в потоках, провести измерения отклонения и дисперсии, а затем предложить и протестировать улучшение.

## 2. Инфраструктура
Реализованы:
- `RandomStreamGen` — генератор потоков строк (символы: [a-zA-Z0-9-], длина ≤ 30).
- `HashFuncGen` — FNV-1a 64-bit хеш.
- `ExactCounter` — точный подсчёт уникальных через `unordered_set`.
- `HyperLogLog` — стандартный HLL с регистрами `uint8_t`.
- `HyperLogLogImproved` — улучшенная версия: sparse/точный участок (до порога `sparse_threshold = 4096`) и 64-bit хеш.

## 3. Выбор параметра B
Параметр `B` задаёт число регистров `m = 2^B`. Теоретическое относительное стандартное отклонение HLL приближённо равно:
- ≈ 1.04 / sqrt(m) (часто используемое),
- в некоторых источниках — 1.32 / sqrt(m) (консервативная оценка для других настроек).

Примеры:
- B=10 → m=1024 → σ_rel ≈ 1.04/√1024 = 1.04/32 = 0.0325 (≈3.25%)
- B=12 → m=4096 → σ_rel ≈ 1.04/64 = 0.01625 (≈1.63%)
- B=14 → m=16384 → σ_rel ≈ 1.04/128 = 0.008125 (≈0.81%)

Я выбрала B=12 как разумный компромисс: память на регистры `m * 1 byte` = 4096 B (~4 KB) + служебное, при этом ожидаемая относительная ошибка ~1.6%.

В результате получаем CSV с колонками: `step_idx,processed,true_unique,hll_est,hll_improved_est`.

Построенные графики:
- `true_vs_estimates.png` — истинные значения Ft0 и оценки HLL / HLL-improved по мере роста обработанного потока.
- `hll_mean_std.png` — пример поведения E(Nt) и ±σ (для одного запуска показан расширяющийся mean/std как приближение).


## 5. Сравнение с теорией
- Теоретический σ_rel при B=12: 1.04/√4096 ≈ 0.01625 (1.625%). Практические отклонения (по экспериментам) лежат рядом с этим порядком величин для больших t.
- Для малых объёмов (small-range) HLL обычно переоценивал/недооценивал — исправление линейным подсчётом применено в коде при E <= 2.5*m.
- Улучшенная версия (sparse до 4096) даёт точные значения до порога и затем продолжает как HLL → уменьшает bias на малых мощностях и уменьшает дисперсию там, где раньше было множество нулевых регистров.

## 6. Улучшения
Предложенное и реализованное улучшение:
1. **Sparse / exact stage**: пока уникальных элементов мало (<= sparse_threshold), сохраняем `unordered_set` — это даёт точность 100% в малой области и резко уменьшает bias для низких кардинальностей (идея из HyperLogLog++ / sparse representation).
2. **64-bit hash (FNV-1a)**: увеличивает пространство хешей, снижая вероятность коллизий и даёт более качественные rho.
3. **Alpha correction**: использована стандартная формула для α_m (HLL++ использует дополнительные эмпирические поправки, но базовая формула уже улучшает оценку).
4. **Экономия памяти**: регистры хранятся в `uint8_t` (1 байт на регистр). Дополнительно можно хранить регистры в битовом упакованном виде (например, 6 бит на регистр), но это усложнит код; в репозитории это отмечено как потенциальная оптимизация.

Влияние улучшений:
- Для малых Ft0 → точность улучшилась до точной (exact) при Ft0 <= sparse_threshold.
- Для больших Ft0 → относительная ошибка сопоставима или чуть лучше (из-за 64-bit hash).
- Дисперсия обычно уменьшается за счёт более корректного поведения на границе small-range.

## 7. Заключение
- стандартный HLL даёт оценку с относительной ошибкой, близкой к 1.04/√m при достаточном количестве уникальных элементов.
- реализовали (sparse + 64-bit), улучшает точность на малых кардинальностях и даёт сопоставимые или лучшие результаты в среднем.
- хоорошие параметры: B=12 (m=4096) как рабочая точка для компромисса точность/память; для большей точности — B=14.
- дальнейшие улучшения: использование HLL++ bias tables, упакованные регистры (packing to bits), использование нескольких независимых HLL и усреднение оценок для уменьшения дисперсии (но с ростом памяти), онлайн-обучение порога sparse.

---